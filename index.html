<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Building bioinformatics command line tools in Rust</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/nord.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/atom-one-dark.css">
	</head>
	<body>
		<!--	Border line around slides		-->
		<div class="line top"></div>
		<div class="line bottom"></div>
		<div class="line left"></div>
		<div class="line right"></div>
		<!--	Border line around slides		-->
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Building bioinformatics command line tools in Rust</h3>ü¶Ä
					<br>
					<p>Michael B. Hall $\in$ Coin Group @ Doherty Institute</p>
					<p style="font-family: 'JetBrains Mono', monospace;font-size: 0.5em"><a href="https://twitter.com/mbhall88">@mbhall88</a> | michael.hall2 [at] unimelb.edu.au</p>
					<p>Slides: <a href="https://mbh.sh/csi-rust">https://mbh.sh/csi-rust</a></p>
				</section>
				<section>
					<h3>üë©‚Äçüíª Interface üë®‚Äçüíª</h3><br>
					<h3>üö´ Errors üö´</h3><br>
					<h3>üöÄ Speed üöÄ</h3>
				</section>
				<section>
					<section>
						<h3>üë©‚Äçüíª Interface üë®‚Äçüíª</h3><br>
						<p><a href="https://github.com/clap-rs/clap">github.com/clap-rs/clap</a></p>
						<pre><code class="language-toml">[dependencies]
clap = { version = "3.1", features = ["derive"] }</code></pre><br>
						<p>Examples from <a href="https://github.com/mbhall88/rasusa">mbhall88/rasusa</a></p>
					</section>
					<section>
						<pre><code data-noescape class="language-rust" data-line-numbers="1-21|1|2-3|5-12">/// Randomly subsample reads to a specified coverage.
#[derive(Parser, Debug)]
#[clap(author, version, about)]
struct Args {
    /// The fast{a,q} file(s) to subsample.
    #[clap(
        short,
        long,
        multiple_values = true,
        required = true
    )]
    pub input: Vec&lt;PathBuf&gt;,
}

fn main() {
    let args = Args::parse();

    for file in args.input {
        println!("Got input file {:?}", file);
    }
}</code></pre>
					</section>
					<section>
						<pre><code data-trim class="language-plaintext">$ rasusa --help
rasusa 0.1.0
Randomly subsample reads to a specified coverage

USAGE:
    rasusa --input &lt;INPUT&gt;...

OPTIONS:
    -h, --help                Print help information
    -i, --input &lt;INPUT&gt;...    The fast{a,q} file(s) to subsample
    -V, --version             Print version information</code></pre>
						<p>Usage</p>
						<pre><code class="language-plaintext">$ rasusa -i someFile
Got input file "someFile"
Got input file "otherFile"</code></pre>
					</section>
					<section>
						<h4>Argument validation</h4>
						<pre><code data-noescape class="language-rust" data-line-numbers="11">/// Randomly subsample reads to a specified coverage.
#[derive(Parser, Debug)]
#[clap(author, version, about)]
struct Args {
    /// The fast{a,q} file(s) to subsample.
    #[clap(
        short,
        long,
        multiple_values = true,
        required = true,
        validator = check_path_exists
    )]
    pub input: Vec&lt;PathBuf&gt;,
}

</code></pre>
					</section>
					<section>
						<h4>Argument validation</h4>
						<pre><code data-noescape class="language-rust">/// A utility function that allows the CLI to error if a path doesn't exist
fn check_path_exists(s: &str) -> Result&lt;(), String&gt; {
    let path = PathBuf::from(s);
    if path.exists() {
        Ok(())
    } else {
        Err(format!("{} does not exist", s))
    }
}</code></pre>
						<pre><code class="language-plaintext">$ rasusa -i existingFile fakeFile
error: Invalid value "fakeFile" for '--input &lt;INPUT&gt;...': fakeFile does not exist

For more information try --help</code></pre>
					</section>
					<section>
						<h4>Custom parsing</h4>
						<pre><code data-noescape class="language-rust" data-line-numbers="5-18|5-10|18|12|14|15|16">/// Randomly subsample reads to a specified coverage.
#[derive(Parser, Debug)]
#[clap(author, version, about)]
struct Args {
    /// u: uncompressed; b: Bzip2; g: Gzip; l: Lzma
    ///
    /// Rasusa will attempt to infer the output
    /// compression format automatically from the
    /// filename extension. This option is used to
    /// override that.
    #[clap(
        short = 'O',
        long,
        value_name = "u|b|g|l",
        parse(try_from_str = parse_compression_format),
        default_value = "u"
    )]
    pub output_type: niffler::compression::Format,
}</code></pre>
					</section>
					<section>
						<h4>Custom parsing</h4>
						<pre><code class="language-rust">fn parse_compression_format(s: &str) -> Result&lt;niffler::compression::Format, String&gt; {
    match s {
        "b" | "B" => Ok(niffler::Format::Bzip),
        "g" | "G" => Ok(niffler::Format::Gzip),
        "l" | "L" => Ok(niffler::Format::Lzma),
        "u" | "U" => Ok(niffler::Format::No),
        _ => Err(format!("{} is not a known output format", s.to_string())),
    }
}</code></pre>
						<p>Usage</p>
						<pre><code class="language-plaintext">$ rasusa -i inFile -O t
error: Invalid value "t" for '--output-type &lt;u|b|g|l&gt;': t is not a known output format

For more information try --help</code></pre>
					</section>
					<section>
						<h4>Short help</h4>
						<pre><code data-trim class="language-plaintext">$ rasusa -h
rasusa 0.1.0
Randomly subsample reads to a specified coverage

USAGE:
    rasusa [OPTIONS] --input &lt;INPUT&gt;...

OPTIONS:
    -h, --help                     Print help information
    -i, --input &lt;INPUT&gt;...         The fast{a,q} file(s) to subsample
    -O, --output-type &lt;u|b|g|l&gt;    u: uncompressed; b: Bzip2; g: Gzip; l: Lzma [default: u]
    -V, --version                  Print version information</code></pre>
					</section>
					<section>
						<h4>Long help</h4>
						<pre><code data-trim class="language-plaintext">$ rasusa --help
rasusa 0.1.0
Randomly subsample reads to a specified coverage

USAGE:
    rasusa [OPTIONS] --input &lt;INPUT&gt;...

OPTIONS:
    -h, --help
            Print help information

    -i, --input &lt;INPUT&gt;...
            The fast{a,q} file(s) to subsample

    -O, --output-type &lt;u|b|g|l&gt;
            u: uncompressed; b: Bzip2; g: Gzip; l: Lzma

            Rasusa will attempt to infer the output compression format automatically from the
            filename extension. This option is used to override that. If writing to stdout, the
            default is uncompressed

            [default: u]

    -V, --version
            Print version information</code></pre>
					</section>
				</section>
				<section>Errors</section>
				<section>Speed</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
			});
		</script>
	</body>
</html>
